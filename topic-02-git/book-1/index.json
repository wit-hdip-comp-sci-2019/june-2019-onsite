


  {
  
  
    "properties" : {},
  
  "type" : "lab",
  "title" : "Lab 01 Introduction",
  "img" : "img/main.png",
  "videoid" : "none",
  "objectives" : "<p>Introducing the fundamentals of git using the command line</p>",
  "folder" : "book-1",
  "link" : "index.html",
  "los": [
   ]
,
  "chapters" : [
  
    {
    "title": "# Objectives",
    "shortTitle": "Lab 01 Introduction",
    "contentMd" : "# Objectives\n\nIntroducing the fundamentals of git using the command line\n\n## Why use a version control system (such as Git)?\n\n* You can keep track of the changes you make to your project as you\n  work on it (like 'save points' in a computer game, you can go back\n  to previous states)\n\n* If you're working on the same project as other people, it helps you\n  handle the synchronization (friction?) points when you make changes\n\n## Why use Git specifically?\n\n* It's the most popular (the default?), and it strikes a good balance\n  between being easy to use, and being powerful\n\n* It's decentralized, so you can do everything offline, and don't need\n  to configure any server\n\n* It makes it easy to try new things locally without having to worry\n  about breaking everything, or losing stuff\n\n## What we'll cover\n\n* Commits - What they are and how to create them\n* Branches - Why they are needed and how to work with them\n* Merging - What it is and the most common types of merging\n* Conflicts - Handling merge conflicts and minimizing the chances of hitting them\n"
    },
  
    {
    "title": "# Commits",
    "shortTitle": "01",
    "contentMd" : "# Commits\n\nA commit is a snapshot of a project at a specific point in time. Think of it as\na 'save point' in a video game. If you mess up your project you can go back to\na working commit.\n\n## Practical One\n\n#### Create a new repository\n\nBefore we create our first commit, we'll need to create a repository.\n\nCreate a new directory.\n\n```bash\nmkdir git-workshop\ncd git-workshop\n```\n\nInitialize a git repository, we will see a hidden `.git` directory created in\nthe current directory. Let's not focus on that too much at the moment.\n\n```bash\ngit init\n# stdout: Initialized empty Git repository in...\n\nls -a\n# stdout: .    ..   .git\n```\n\n#### Create a commit\n\nWe have our repository created. Let's create a new file with some text inside\nit.\n\n```bash\necho 'Hello, World!' > hello.txt\n```\n\nWe can now add the `hello.txt` file to the staging area, ready to be committed.\nAny future changes to `hello.txt` will not be included in the commit we create,\nunless we add them too.\n\n```bash\ngit add hello.txt\n```\n\nFinally we can create a commit using the contents of the staging area, and\ninclude a descriptive message of our changes.\n\n```bash\n# Alternatively we can just do 'git commit', which will open up an editor to\n# enter the commit message.\ngit commit -m \"Add hello.txt\"\n```\n\nWe have created a commit, now let's create another one by making some changes\nto `hello.txt`. We'll leave this one to you, but our change could look\nsomething like:\n\n```bash\necho 'My name is <your-name>!' >> hello.txt\n```\n\n#### Viewing commit history\n\nWe have two commits created, let's take a look at the commit log.\n\n```bash\ngit log\n```\n\nThe commits are ordered in reverse chronological order. Each commit item\ncontains the SHA-1 hash of the commit, the author, the date the commit was\nauthored and the commit message. We can use the SHA-1 hash of the commit to\nreference it when using other git commands.\n\nFor example, we can *checkout* a commit:\n\n```bash\ngit checkout <commit-sha-1>\ncat hello.txt\n# stdout: Hello, World!\n\n# Use 'git checkout -' to checkout the previous commit.\ngit checkout -\ncat hello.txt\n# stdout: Hello, World! My name is <your-name>\n```\n\n## Diving deeper\n\nWe covered quite a lot in the previous practical. Let's go in depth on some of\nthe topics covered.\n\n### Adding (Staging) and Committing\n\nWhen performing a `git add` we mentioned the \"staging area\". This is one of the\nthree sections of a git project:\n\n* The working directory - This is all the files in your current directory. This\nis where files are modified before being staged.\n\n* The staging area - This is where changes are added during `git add`, when a\ncommit is created the changes in the staging area will be the contents of the\ncommit.\n\n* The repository - Changes that have been committed and persisted.\n\n![Sections of a git project](./img/staging-and-comitting.png)\n\n### Lifecycle of files\n\nThere are two states of a file in git:\n\n* Tracked files - This is any file that is in the previous commit, or currently\nstaged.\n\n* Untracked files - Any file that is not a tracked file.\n\nA tracked file can be:\n\n* Modified: Changes have been made since the previous commit, but are not\nstaged.\n\n* Staged: Changes have been made since the previous commit, and those changes\nare staged.\n\n* Unmodified: No changes have been made to the file since the last commit.\n\n![File lifecycle](./img/file-lifecycle.png)\n\n## Practical Two\n\nNow we know a bit more about staging and the lifecycle of a file, let's have a\nlook at the lifecycle in action.\n\nFirst, let's create a new untracked file.\n\n```bash\necho 'My favourite colour is <your-favourite-colour>!' > colour.txt\n```\n\nNow we want to see the status of the current project.\n\n```bash\ngit status\n```\n\nIt tells us we have an untracked file called 'colour.txt'. As we haven't\nchanged the contents of 'hello.txt' it is unmodified and does not show by\ndefault.\n\nIf we `add` 'colour.txt' to the staging area and check the status again we will\nsee git is now telling us the file is staged or ready to be committed, the file\nis now also tracked.\n\n```bash\ngit add colour.txt\n\ngit status\n# Note that the output also tells us how to unstage the file, using git reset.\n```\n\nNow let's change the contents of 'hello.txt', the file will then become\nmodified and this will be shown when running `git status`.\n\n```bash\necho 'I am doing a Git workshop!' >> hello.txt\n\ngit status\n```\n\nFinally `add` and `commit` all of the changes.\n\n\n"
    },
  
    {
    "title": "# Branches",
    "shortTitle": "02",
    "contentMd" : "# Branches\n\nA branch is just a reference to a commit, it has a human-readable name\nand identifier. Instead of using the SHA-1 hash to reference a commit we can\nnow use the name of a branch.\n\nWhen creating a repository using `git init` a branch named 'master' is created\nfor us, it is currently pointed at our latest commit.\n\n![The current state of our repository](./img/basic-branch.png)\n\nLet's designate 'master' as the branch for our main line of development,\nanything on that branch should be stable. If we want to test out new features\nwithout breaking the main line then we can create new branches.\n\n## Practical One\n\nWe want to add a new file to our current project, but we don't want to mess up\n'master'.\n\n#### View the current branches\n\nWe can see all of the branches in our repository.\n\n```bash\ngit branch\n# stdout: master\n```\n\n#### Create a new branch from master\n\nTo add our new feature we want to add a new branch. Our new feature is adding\ninformation about our favourite animal so let's call the branch something\ndescriptive like 'favourite-animal'.\n\n```bash\ngit branch favourite-animal\n# If we do a 'git branch' now we'll see our new branch is created, but we're\n# still on master. Let's 'checkout' our new branch.\n\ngit checkout favourite-animal\n```\n\nNow that we have our branch created let's take a look at our commit history\nusing `git log`, this will give us information about what commit each branch is\ncurrently pointing to.\n\n#### Make some changes\n\nLet's make some changes to our new branch and commit them.\n\n```bash\necho 'My favourite animal is a <your-favourite-animal>!' > animal.txt\n\ngit add animal.txt\ngit commit -m \"Add favourite animal\"\n```\n\nWe now have a repository that looks like this.\n\n![The new state of our repository](./img/two-branches.png)\n\n## Diving deeper\n\n### Branches under the hood\n\nBranches are stored in the `.git/refs/heads` directory as files. If we view the\ncontents of any of these files they just contain the SHA-1 hash of the commit\nthe branch is currently pointing to.\n\n```bash\ncat .git/refs/heads/favourite-animal\n```\n\n### HEAD\n\nWhen we were doing `git log` you may have seen 'HEAD' mentioned in the log.\nHEAD points to whatever is currently checked out. At the moment we have the\n'favourite-animal' branch checked out so it will point to that. HEAD is a file\nin the `.git` directory.\n\n``` bash\ncat .git/HEAD\n# stdout: ref: refs/heads/favourite-animal\n```\n\n## Practical Two\n\nWe have created a branch that has information about our favourite animal. Now\nlet's create another branch from master and add information about our favourite\nTV show. We are currently on the branch 'favourite-animal'. We need to create\nour new branch from master.\n\n```bash\n# Create a new branch named favourite-show from the branch master\ngit branch favourite-show master\ngit checkout favourite-show\n```\n\nWe'll leave the rest to you.\n"
    },
  
    {
    "title": "# Merging",
    "shortTitle": "03",
    "contentMd" : "# Merging\n\nIn the last section, we learned about creating new branches. Often branches are\ncreated temporarily to work on a specific piece of work. When that work is\nready, then those changes are brought back into the main line again.\n\nRemember the branches from the last section? Originally there was the master\nbranch, and then we created a branch called 'favourite-animal', where we made\nchanges. We can now merge those changes back into master branch, and delete the\n'my-new-branch' since we won't need it anymore.\n\n## Practical One - Fast-forward merging\n\nThe simplest form of merging is *fast-forward* merging. Since branches are just\nreferences to commits, and 'favourite-animal' is a direct descendant of master;\nwe can just update master to point to the same commit as 'favourite-animal'.\n\nThis is the default way that git will merge when the target branch is an\nancestor of the source branch. First, `checkout` the target branch (master in\nthis case), and then use the `merge` subcommand to bring the changes from the\nsource branch (favourite-animal) into this branch:\n\n```bash\ngit checkout master\n\ngit merge favourite-animal\n```\n\nMaster and the 'favourite-animal' branch are now pointing at the same commit.\nWe can delete the 'favourite-animal' branch.\n\n```bash\ngit branch -d favourite-animal\n```\n\n## Practial Two - Merge commits\n\nIn some cases, the target branch will not be a direct ancestor of the source\nbranch. This is the case for our 'favourite-show' branch. Here, the default\naction is to create a new commit which has two (or more) *parent* commits and a\nmessage.\n\n![Before creating a merge commit](./img/basic-merging-before.png)\n\nWhile on the master branch, we can now merge the changes from the\n'favourite-show' branch as follows:\n\n``` bash\ngit merge favourite-show\n```\n\nThe default commit message editor will have appeared here, to give you the\nopportunity to modify the commit message for the new commit. The default is\nusually fine.\n\n![After creating a merge commit](./img/basic-merging-after.png)\n\nUsually a *merge commit* will not contain any changes to files itself. The\nchanges will be in its ancestors. Sometimes when merging two divergent branches\nthough, there will be conflicting changes on either side of the merge. In this\ncase, there may be changes needed in the merge commit to resolve the conflicts.\n"
    },
  
    {
    "title": "# Conflicts",
    "shortTitle": "04",
    "contentMd" : "# Conflicts\n\n## What are conflicts, and how do they happen?\n\nConflicts in git occur when trying to integrate changes from two different\nstates, where different changes are made in one place. The most common case is\nwhen performing a *merge* of one branch into another, where there's a change to\na particular line in a particular file on both sides of the merge.\n\nGit doesn't know what to do automatically, so it just stops in the middle of\nthe action, and asks you to intervene.\n\n## Practical One\n\nFirst, let's make a new branch and add a file:\n\n``` bash\ngit checkout -b left master\n\necho \"Left is the best\" > conflict.txt\n\ngit add conflict.txt\ngit commit -m \"Left is the best\"\n```\n\nNext, for the purposes of demonstration, let's create another branch, \ncalled `right`:\n\n```bash\ngit checkout -b right master\n\necho \"Right is the best\" > conflict.txt\ngit add conflict.txt\ngit commit -m \"Right is the best\"\n```\n\nWe've made changes here in the same file, in two separate \nbranches. If we try to integrate these branches with a merge, \nwe're going to see a conflict. Let's merge `the-left` into \n`the-right` to see a conflict:\n\n```bash\ngit merge left\n```\n\nWe now are told that there has been a conflict while perfoming the merge. Git\nhas stopped the merge process and asked us to resolve the conflict before\ncontinuing. We can check the status of our repo to see the unmerged paths and\ninstructions on how to resolve the conflict.\n\n```bash\ngit status\n```\n\nLet's open 'conflict.txt' in an editor and go through how to resolve a\nconflict. This is the content of our file:\n\n```\n<<<<<<< HEAD\nRight is the best\n=======\nLeft is the best\n>>>>>>> left\n```\n\nWhat are the components of this block? This block is saying that the version of\nthe change in HEAD (right branch) is above the '=======' and everything below\nit is the change in the branch named 'left'. We can choose to keep one of these\nchanges, keep both, or change the content to something different.\n\nLet's update the contents of the file to:\n\n```\nRight and Left are both equally good\n```\n\nWith our conflict manually resolved, we need to `git add`:\n\n```\n# Stage our change and mark conflict as resolved\ngit add conflict.txt\n```\n\nLets check our `git status` once more.\n\n```bash\ngit status\n```\n\nIt tells us that all the conflicts have been resolved, but we are still in the\nmerging process. Finally, commit the integrated change. This will prompt for a\ncommit message. Leaving the default message is fine.\n\n```bash\ngit commit\n```\n\n## Diving deeper\n\n#### Aborting a merge\n\nWe can abort a merge that's in progress by using the `git merge --abort`\ncommand.\n\n##### Minimising merge conflicts\n\nTo minimise merge conflicts keep commits small and integrate changes often.\n"
    }
  
  ]
  }

